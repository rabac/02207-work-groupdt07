\documentclass[11pt,a4paper]{article}

\usepackage{url,,}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{listings}
\usepackage{fullpage}
\usepackage{fancyhdr,a4wide}
\usepackage{makeidx}
\usepackage{placeins}
\usepackage[procnames,noindent]{lgrind}

\lstset{ %
language=VHDL,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
showstringspaces=false,         % underline spaces within strings
%numbers=left,                   % where to put the line-numbers
%numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
%stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
%numbersep=5pt,                  % how far the line-numbers are from the code
%backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces within strings adding particular underscores
showtabs=false,                 % show tabs within strings adding particular underscores
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\begin{document}	

\begin{titlepage}

\thispagestyle{fancy}
\lhead{}
\chead{
\large{\textit{
Informatics and Mathematical Modelling\\
Technical University of Denmark}}}
\rhead{}
\rule{0pt}{50pt}
\vspace{3cm}

\begin{center}

 	\huge{\textbf{02207 : Advanced Digital Design Techniques}}\\
 	\vspace{1cm}
 	\huge{Design for Low Power by Reducing Switching Activity}\\
 	\vspace{1cm}
 	\huge{\textit{LAB 2}}\\
 	\vspace{1cm}
 	\huge{Group \textit{dt07}}\\
\end{center}

\vspace{4cm}

\begin{flushright}
	\LARGE{Markku Eerola (s053739)}\\
	\vspace{0.3cm}
	\LARGE{Rajesh Bachani (s061332)}\\
	\vspace{0.3cm}
	\LARGE{Josep Renard (s071158)}\\
\end{flushright}
\cfoot{\today}
\end{titlepage}

%\begin{abstract}
%\centering
%Abstract to be created.
%\end{abstract}

%-----------------------------------------------------------
\newpage 
\tableofcontents

\newpage 
\section{Introduction}

The purpose of this exercise was to estimate the power dissipation in a digital circuit due to the switching activity in the cells. Power is dissipated in a digital circuit, dynamically, in two ways; one, the power that is spent in charging or discharging the capacitance load connected to the output of the cell, and two, the power dissipated inside the cell due to short circuit currents and the internal capacitance charging or discharging. This holds for combinational cells. For sequential cells, there is extra power spent at every clock cycle, even if the output of the cell does not change. This is because there is some reaction to every clock cycle in sequential cells, which would take some power. 

Static power in digital circuits is due to the internal leakage currents in CMOS. Though, in this exercise, we are particularly interested in analyzing the dynamic power dissipation.

We estimate the dynamic power in a serial to parallel converter. The converter takes in 8 bits (one byte) in every clock cycle, and gives out 32 bits (4 bytes) after every 4 clock cycles. The input byte at the first clock cycle is the most significant byte in the output, whereas the input byte in the fourth clock cycle is the lowest significant byte. The converter, thus, waits for four clock cycles to produce an output.

In the next section \ref{section:designs}, we discuss three designs for such a converter. In section \ref{section:simulation}, we simulate the VHDL code for the designs using Modelsim, and verify that all the designs are working correctly. The VHDL code is then synthesized using Design Vision, and a switching activity is produced using VSS simulator. Based on this switching activity, a power report is presented for the synthesized design. These reports are presented in the last section \ref{section:impl}, which also contains the VHDL code for the designs. In section \ref{section:power}, we discuss the results obtained.

\subsection{Authors by Section}
\begin{itemize}
\item \textit{Markku Eerola} 
\item \textit{Josep Renard} 
\item \textit{Rajesh Bachani} 
\end{itemize}

\newpage
\section{Designs for Serial to Parallel Conversion}
\label{section:designs}
In this section, we give an overview of the three designs for serial to parallel conversion, which are evaluated for their power consumption in this exercise.

\subsection{Design A: Shift Register}

\begin{figure}[htp]
\centering
\includegraphics[width = 4in]{./images/shiftregister.jpg}
\caption{Converter using a 8-bit Shift Register}
\end{figure}

The shift register is implemented with a simple way, first he makes a movements of 8 bits to the next significant 8 bits and finally he stores on the eight first the input data, the shift register works until the clock stops. Here the input is only connected with the register of less important bits.

\newpage
\subsection{Design B: Register with Enable}

\begin{figure}[htp]
\centering
\includegraphics[width = 4in]{./images/shiftregisterenable.jpg}
\caption{Converter using 8-bit Registers with Enable}
\end{figure}

For implement the shift register with an enable signal we use a multiplexor that open the door for store in a register, I mean the multiplexor is a filter that manage which register is going to store the input data, so the shift functionality is secure, the multiplexor make possible to store the first input on the most significant bits without through for the previous registers like the default shift register. In that version the input data is connected at the multiplexor and he give to the register the previous value of the register or the new input depending the value of the enable.

\newpage

\subsection{Design C: Register with Clock-Gating}


\begin{figure}[htp]
\centering
\includegraphics[width = 4in]{./images/shiftregistergated.jpg}
\caption{Converter using 8-bit Registers with Clock Gating}
\end{figure}

The shift register gated is developed using the same idea that the enable of doesn't across for all the registers to store the most significant 8 bits, but now we manage the clocks of the registers, how? very easy. We use a counter that is continuously counting 0 to 3 and depending the number of the counter the next entity, the decoder, enables a register for store the data with his clock, so the decoder open the register to store with the clock. The registers receive the input data all the time but only which is with the clock period open can store the data.


\newpage
\section{Simulation of the designs with Modelsim}
\label{section:simulation}
All the three designs are simulated with Modelsim, to verify the functionality.
 
The following two screenshots demonstrate the working of implementation for Design A. The first screenshot id taken at 33ns while the second is taken at 43ns. It can be seen that in a new clock cycle, the 8 bit registers ripple their values to the more significant register, and the value of Qk for that clock cycle is fed into the least significant register.

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsr1.png}
\caption{Simulation screenshot for Design A at 33ns}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsr2.png}
\caption{Simulation screenshot for Design A at 43ns}
\end{figure}

\newpage
The following screenshots are from the simulation of Design B. In the first instance, which is at 14ns on the timeline, we have some value at Qk, but no value at Q. Then, at 24ns, the value of Qk in the previous clock cycle is loaded into the most significant register. Further on, at 33ns, the value of Qk in the previous clock cycle is loaded into the second most significant register. This repeats for four clock cycles.

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsre1.png}
\caption{Simulation screenshot for Design B at 14ns}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsre2.png}
\caption{Simulation screenshot for Design B at 24ns}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsre3.png}
\caption{Simulation screenshot for Design B at 33ns}
\end{figure}

\newpage
Then, for Design C, we have the following screenshots. As we can see, the values of Qk are transferred to the output to different registers. Also, the values of Qk are transferred in the same clock cycle, which was not the case with the Design B.

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsrg1.png}
\caption{Simulation screenshot for Design C at 14ns}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[length = 4in,width = 6.5in]{./images/simsrg2.png}
\caption{Simulation screenshot for Design C at 24ns}
\end{figure}

\newpage
\section{Power Reports and Discussion}
\label{section:power}

In this section we discuss the results obtained from the simulations which were presented in section \ref{section:simulation}. For a short recap, the results can be seen in table \ref{table:power}:

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{}	& \textbf{Total Dynamic Power}		& \textbf{Cell Leakage Power}\\ \hline
Design A &	55.2 uW				& 773.7 nW \\ \hline
Design B &	47 uW					& 800.5 nW \\ \hline
Design C &  32.6 uW				& 835.0 nW \\ \hline
\end{tabular}
\end{center}
\caption{Overview of Results from Power Reports}
\label{table:power}
\end{table}

It is quite clear from the results that Design A consumes the most power (dynamic), while Design C is the most efficient, among the three designs. Though, this was expected at the beginning of the exercise. The static power, which comes from the internal leakage currents, is considerably low as compared to the dynamic power, in all the designs. So, we would not consider it in our analysis. Also, we would mean dynamic power when writing power, from now on.

In Design A, there is a transition at the output of each of the four registers, in every clock cycle. The input Qk is transferred from one register to the adjacent more significant register, every clock cycle, until it reaches the most significant register where it is just overwritten in the next clock cycle. This is the reason why the design is much consuming in terms of power. In every clock cycle, there is a switching activity in all the outputs of the four registers. Since switching accounts for a lot of power, for the entire time line of the simulation, we have high levels of power consumption. 

Design B is efficient than Design A. Switching in Design B is controlled by the enable signals, which indicate which register should be loaded with Qk in the next clock event. If the enable signal is SET, the register is loaded with Qk, otherwise, the output is the same (rather, the previous value is reloaded into the register). What makes this design efficient than Design A is the reduction in the switching activity in terms of loading the register only when the enable is SET. 

The overhead in this design, though, is the logic for the enable signals. It is interesting to note here that we have not implemented the logic for the enable signals as a separate combinational block. The enable signals are governed from the test bench, which was provided for the exercise. Thus there is no measure of the power dissipation in the enable block, which we think would be considerable. Also, from the lecture notes, we see that the ratio of power dissipated in Design A to that in Design B is 1:1.19, which indicates that Design B should consume more power. We believe this discripancy is because of we not implementing the enabling logic specifically.

Lets consider Design C now. It is quite clear that this design is the most efficient than both Design A and Design B. This design is based on clock-gating, which means that the original clock signal is not sent directly to the registers, but sent only when the register should be loaded with a new value. This has the power saving advantage when compared with Design B. When the register gets a clock cycle, it loads Qk. Otherwise, there is no internal power dissipation due to clock cycles for which the output does not change. In Design B, even if the enable for a register was RESET, which meant that the register would output would not change, still, since there was a clock cycle there was some power dissipated internally in the cell. This is avoided tremendously in Design C. And moreover, since the switching activity is directly propotional to the clock cycles arriving, reducing the clock cycles to individual registers means reducing unnecessary switching activity.

%The results differ slightly from what we expected on the register which was implemented with multiplexers and enable signals. Otherwise the results were not surprising.

%We had expected that since the datapath was shallow, the power dissipation from the logic controlling the enabling signals and from the multiplexors would be more than the savings that are gained by eliminating unnecessary transitions in the 8-bit registers. According to these expectations the shiftregister with register enabling should have been powerhungrier than the shiftregister without register enabling. The simulation results, however, clearly show that this was not the case.

%The shiftregister with clock gating performed pretty much as we expected. We expected it to have less power dissipation than the regular shiftregister, even with the shallow datapath, since the clock control logic was simple enough not to cause more power dissipation than what is avoided by eliminating three quarters of the 8-bit register transitions.

%In our opinion the most likely reason for why the shiftregister with register enabling performed unexpectedly is the implementation of the enable signal control logic: The enable signal was controlled by logic within the test bench and was thus outside the scope of the power reports.

%Judging by the obtained results we can safely say that if low power is the number one priority (after timing of course, we want our circuit to work) then clock gating is a better method than register enabling, as clock gating gave good results even with a shallow data path. With a deeper datapath the register enabling should become a feasible option and the deeper the datapath the smaller the differences between the two techniques (powerwise) should become. Register enabling will of course demand more area than clock gating since it requires multiplexors as well as the control logic, but on higher clock frequencies clock gating can cause problems with timing because of added delay. Thus it can be said that both techniques have their uses.




\newpage
\section{Implementation and Power Reports}
\label{section:impl}

\lstinputlisting[frame=trbl, caption={SHIFTREG.vhd}]{../code/SHIFTREG.vhd}
\newpage
\lstinputlisting[frame=trbl,caption={SHIFTREG\_ENABLE.vhd}]{../code/SHIFTREG_ENABLE.vhd}
\newpage
\lstinputlisting[frame=trbl,caption={SHIFTREG\_GATED.vhd}]{../code/SHIFTREG_GATED.vhd}
\newpage
\lstinputlisting[frame=trbl,caption={REG.vhd}]{../code/REG.vhd}
\lstinputlisting[frame=trbl,caption={MUX.vhd}]{../code/MUX.vhd}
\newpage
\lstinputlisting[frame=trbl,caption={COUNTER.vhd}]{../code/counter.vhd}
\lstinputlisting[frame=trbl,caption={DECODER.vhd}]{../code/DECODER.vhd}
\newpage
\lstinputlisting[frame=trbl, caption={Power Report Design A}]{../code/power_report1.txt}
\newpage
\lstinputlisting[frame=trbl, caption={Power Report Design B}]{../code/power_report2.txt}
\newpage
\lstinputlisting[frame=trbl, , caption={Power Report Design C}]{../code/power_report3.txt}
\end{document}